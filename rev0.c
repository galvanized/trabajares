#pragma config(Motor,  port2,           mRF,           tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port3,           mLF,           tmotorVex393_HBridge, openLoop, encoderPort, None)
#pragma config(Motor,  port4,           mLB,           tmotorVex393_HBridge, openLoop, encoderPort, None)
#pragma config(Motor,  port5,           mRB,           tmotorVex393_HBridge, openLoop, reversed, encoderPort, None)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*

				Y+
 LB			^    LF
  1     |     0
				|
 X-<----+----> X+  FRONT
				|
				|
 RB			v		 RF
	2			Y-    3

Shane Galvin 2017 CC Attribution 4.0 International
*/

/*byte xPower = 255; // forward/back
byte yPower = 255; // translate
byte rPower = 255; // rotate
bool transMatrix[4] = {0, 1, 0, 1};
bool turnMatrix[4] = {0, 0, 1, 1};*/

byte axisScale(byte in){ // provides deadzone functionality
		byte threshold = 10; // deadzone
		if(abs(in)<threshold){
			return 0;
		}
		else{
			//return in;
			byte inSign = sgn(in)*2+1; // gives sign multiplier (-1,1)
			short inSht = abs(in - threshold) * 128; // hold input value in short for better scaling
			// scale such that at threshold, output = 0, and at maximum, output equals maximum
			// slope equals maximum (128) divided by maximum minus threshold
			inSht*=(32767/(32767-threshold*128)); // approximates (128/(128-threshold))
			return (byte)(inSht/128*inSign);
		}
}

byte capSum(byte x, byte y, byte z){
	// add up three bytes, returning a byte
	// prevents overflows
	short sum = (short) x + (short) y + (short) z;

	if( sum > 127 ) sum = 127;
	else if( sum < -128 ) sum = -128;

	return (byte) sum;
}

void omniDrive(byte x, byte y, byte r){

	motor[mLF] = capSum(x, y, r);//short(x) + short(y) + short(r);
	motor[mLB] = capSum(x, -y, r);//short(x) + short(-y) + short(r);
	motor[mRF] = capSum(x, -y, -r);//short(x) + short(y) + short(-r);
	motor[mRB] = capSum(x, y, -r);//short(x) + short(-y) + short(-r);

}

void tankDrive(){
	motor[mLF] = axisScale(vexRT[Ch3]);
	motor[mLB] = axisScale(vexRT[Ch3]);
	motor[mRF] = axisScale(vexRT[Ch2]);
	motor[mRB] = axisScale(vexRT[Ch2]);
}

task main(){
	while(true){
		delay(10);
		omniDrive(vexRT[Ch3], vexRT[Ch4], vexRT[Ch1]);
	}
}

/*
task main()
{

	while(true){
		delay(10);
		motor[motorLeft] = axisScale(vexRT[Ch3]);
		motor[motorRight] = axisScale(vexRT[Ch2]);
		if(vexRT[Btn5U]){
			motor[motorClaw] = clawPower;
		}
		else{
			if(vexRT[Btn5D]){
				motor[motorClaw] = -clawPower;
			}
			else{
				motor[motorClaw] = 0;
			}
		}
		if(vexRT[Btn6U]){
			motor[motorArm] = armPower;
		}
		else{
			if(vexRT[Btn6D]){
				motor[motorArm] = -armPower;
			}
			else{
				motor[motorArm] = 0;
			}
		}

	}
}*/
