#pragma config(Motor,  port1,           mLB,            tmotorNone, openLoop)
#pragma config(Motor,  port2,           mRF,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           mLF,           tmotorVex393_MC29, openLoop, encoderPort, None)
#pragma config(Motor,  port4,           mALB,           tmotorVex393_MC29, openLoop, encoderPort, None)
#pragma config(Motor,  port5,           mRB,           tmotorVex393_MC29, openLoop, reversed, encoderPort, None)
#pragma config(Motor,  port6,           mC,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           mALT,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           mART,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           mARB,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          mW,          tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
				Y+
 LB			^    LF
  1     |     0
				|
 X-<----+----> X+  FRONT
				|
				|
 RB			v		 RF
	2			Y-    3


	Platform Type: VEX 2.0 Cortex
	Natural Language PLTW


Shane Galvin 2017 CC Attribution 4.0 International
*/

byte armUpPow = 127;
byte armDownPow = -128;
byte armNeutralPow = 0;

byte clawOpenPow = 127;
byte clawClosePow = -127;
byte clawNeutralPow = 0;

byte winchPow = 127;

byte axisScale(byte in){ // provides deadzone functionality
		byte threshold = 10; // deadzone
		if(abs(in)<threshold){
			return 0;
		}
		else{
			//return in;
			byte inSign = sgn(in)*2+1; // gives sign multiplier (-1,1)
			short inSht = abs(in - threshold) * 128; // hold input value in short for better scaling
			// scale such that at threshold, output = 0, and at maximum, output equals maximum
			// slope equals maximum (128) divided by maximum minus threshold
			inSht*=(32767/(32767-threshold*128)); // approximates (128/(128-threshold))
			return (byte)(inSht/128*inSign);
		}
}

byte capSum(byte x, byte y, byte z){
	// add up three bytes, returning a byte
	// prevents overflows
	short sum = (short) x + (short) y + (short) z;

	if( sum > 127 ) sum = 127;
	else if( sum < -128 ) sum = -128;

	return (byte) sum;
}

void omniDrive(byte x, byte y, byte r){

	motor[mLF] = capSum(x, y, r);//short(x) + short(y) + short(r);
	motor[mLB] = capSum(x, -y, r);//short(x) + short(-y) + short(r);
	motor[mRF] = capSum(x, -y, -r);//short(x) + short(y) + short(-r);
	motor[mRB] = capSum(x, y, -r);//short(x) + short(-y) + short(-r);

}

void setArm(byte power){
	//Set arm power. Up is positive.
	motor[mALT] = power;
	motor[mALB] = power;
	motor[mART] = power;
	motor[mARB] = power;
}


void rcControl(){
	/* allow human control of the arm and pinchers
									Control Setup

				left											right
				5U - Claw Open 						6U - Arm Up
				5D - Claw Close						6D - Arm Down

				8U & 8D
				Winch Retract & Reverse
				(reverse only with ratchet up!)

	*/
	omniDrive(vexRT[Ch3], vexRT[Ch4], vexRT[Ch1]);

	if(vexRT[Btn6U]) setArm(armUpPow);
	else{
		if(vexRT[Btn6D]) setArm(armDownPow);
		else setArm(armNeutralPow);
	}

	if(vexRT[Btn5U]) motor[mC] = clawOpenPow;
	else{
		if(vexRT[Btn5D]) motor[mC] = clawClosePow;
		else motor[mC] = clawNeutralPow;
	}

	if(vexRT[Btn8U]) motor[mW] = winchPow;
	else{
		if(vexRT[Btn8D]) motor[mW] = -winchPow;
		else motor[mW] = 0;
	}

}

task main(){
	while(true){
		delay(10);
		rcControl();
	}
}
